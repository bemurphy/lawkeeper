{"name":"Lawkeeper","tagline":"Lawkeeper - Simple authorization policies for Rack apps","body":"# Lawkeeper\r\n\r\nLawkeeper - Simple authorization policies for Rack apps\r\n\r\nLawkeeper was heavily inspired by the Pundit authorization gem.  Lawkeeper\r\nfollows a very similar pattern, but is more agnostic and geared towards use\r\nin smaller Rack applications.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'lawkeeper'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install lawkeeper\r\n\r\n## Usage\r\n\r\nLawkeeper makes a couple basic assumptions\r\n\r\n* You have a `current_user` helper\r\n* You create policy files like `PostPolicy` for a `Post` model\r\n* You have a headers method with a settable hash for response headers\r\n\r\nAfter setting up your model policies, include `Lawkeeper::Helpers`\r\ninto your app.  Let's assume Sinatra as our example:\r\n\r\n```ruby\r\nhelpers do\r\n  include Lawkeeper::Helpers\r\nend\r\n```\r\n\r\nThis provides a few useful helpers:\r\n\r\n* `can?` - for checking if the current_user is permitted an action on the\r\n  record\r\n* `authorize` - checks if the user can perform the action, otherwise raise\r\n  `Lawkeeper::NotAuthorized`\r\n* `skip_authorization` - used to flag an action as not needing authorization\r\n\r\n### Declaring policy classes\r\n\r\nBy default, Lawkeeper follows a convention of mapping policy classes like\r\n`PostPolicy` for a `Post` class, `CommentPolicy` for `Comment`, etc.\r\n\r\nThe simplest way to declare a post policy is inherit `Lawkeeper::Policy`\r\nand declare predicates for policy checks:\r\n\r\n```ruby\r\nclass PostPolicy < Lawkeeper::Policy\r\n  def read?\r\n    true\r\n  end\r\n\r\n  def update?\r\n    record.owned_by?(user)\r\n  end\r\nend\r\n```\r\n\r\nLawkeeper makes no assumptions about the name of your policy queries.  You can\r\ncall them `show?` or `read?`, `delete?` or `destroy?`, whichever you prefer.  The\r\nonly requirement is that they end with '?'.\r\n\r\nPolicy classes are instantiated with the current user and a record for checking.\r\n\r\nIf you wish to use an unconventially named Policy class for a model, add the\r\n`.policy_class` class method to your model.  For example:\r\n\r\n```ruby\r\nclass Post\r\n  def self.policy_class\r\n    OwnershipPolicy\r\n  end\r\nend\r\n```\r\n\r\nLawkeeper helper methods will prefer the `policy_class` specified if it exists.\r\n\r\n### Specifying Scope classes for policy use\r\n\r\nFor finding records for collection records (like an index) it is possible to\r\ndo scoped find if your relational or document mapper permits it.  This is\r\naccomplished by creating a `Scope` class inside your policy class.  Take\r\nthis example for Ohm:\r\n\r\n```ruby\r\nclass PostPolicy < AppPolicy\r\n  class Scope < Lawkeeper::Policy::Scope\r\n    def resolve\r\n      scope.find(published: \"true\")\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nYou can proceed to use this in an action to find posts where published is the\r\nstring \"true\":\r\n\r\n```ruby\r\n@posts = policy_scope(Post)\r\n```\r\n\r\nThe policy scope lookup is handled by a scope finder stored at `Lawkeeper.scope_finder`.\r\nCurrently Ohm and ActiveRecord adapters are provided.  The finder only has one requirement,\r\nit must respond to `call`.  You can use a class method or Proc to facilitate this.  It\r\nshould return a capitalized string representing the class, such as \"Post\" or \"Comment\".\r\n\r\nIf you wish to use `policy_scope` you should configure a finder appropriate for your storage:\r\n\r\n```ruby\r\nLawkeeper.scope_finder = Lawkeeper::ScopeFinders::Ohm\r\n# or\r\nLawkeeper.scope_finder = Proc.new { |s| ... }\r\n```\r\n\r\n### Authorizing in actions\r\n\r\nTo authorize in a controller action is simple:\r\n\r\n```ruby\r\nget \"/post/:id\" do\r\n  @post = Post.find(id)\r\n  authorize @post, :read\r\n  erb :post_show\r\nend\r\n```\r\n\r\nIf authorize is permitted (which it usually should be) the action will continue\r\nas normal.  If it fails, Lawkeeper::NotAuthorized will be raised.\r\n\r\n### Checking in views\r\n\r\nLawkeeper provides a `can?` helper to use in your views:\r\n\r\n```ruby\r\n<% if can? :edit, @post %>\r\n  <a href=\"/posts/<%= @post.id %>/edit\">Edit Post</a>\r\n<% end %>\r\n```\r\n\r\nThe `can?` method is a check, it will not raise authorization exceptions.\r\n\r\n### Specifying policy classes\r\n\r\nIf you wish to specify a policy class at runtime for a call to `can?` or `authorize`,\r\nyou can pass a policy class as an option third argument.\r\n\r\n```ruby\r\nauthorize @post, :read, OwnershipPolicy\r\n```\r\n\r\n## Ensuring authorization with middlewares\r\n\r\nLawkeeper provides `EnsureWare` for checking that authorization was performed\r\nfor all actions.  When the `authorize` or `skip_authorization` methods are\r\nemployed in actions, response headers are set.  The middleware then checks\r\nand deletes the headers.  If the header was not present, a 403 forbidden status\r\nwill be returned.\r\n\r\nThis is useful to ensure you do not forget to authorize the resource in any\r\ngiven action.\r\n\r\nIf you do not wish to enforce such a check, you should employ the `ScrubWare`\r\nmiddleware instead.  This is simply responsible for stripping Lawkeeper headers\r\nbefore sending the response on its way.\r\n\r\nIf you'd prefer to not use middleware at all, it's advised you set Lawkeeper to\r\nsimply skip the setting of headers:\r\n\r\n```ruby\r\nLawkeeper.skip_set_headers = true\r\n```\r\n\r\nThis will not prevent how Lawkeeper does its primary job of authorizing policy\r\nactions.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}