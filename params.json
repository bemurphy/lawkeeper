{"name":"Lawkeeper","tagline":"Lawkeeper - Simple authorization policies for Rack apps","body":"# Lawkeeper\r\n\r\nLawkeeper - Simple authorization policies for Rack apps\r\n\r\nLawkeeper was heavily inspired by the Pundit authorization gem.  Lawkeeper\r\nfollows a very similar pattern, but is more agnostic and geared towards use\r\nin smaller Rack applications.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'lawkeeper'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install lawkeeper\r\n\r\n## Usage\r\n\r\nLawkeeper makes a couple basic assumptions\r\n\r\n* You have a `current_user` helper\r\n* You create policy files like `PostPolicy` for a `Post` model\r\n* You have a headers method with a settable hash for response headers\r\n\r\nAfter setting up your model policies, include `Lawkeeper::Helpers`\r\ninto your app.  Let's assume Sinatra as our example:\r\n\r\n```ruby\r\nhelpers do\r\n  include Lawkeeper::Helpers\r\nend\r\n```\r\n\r\nThis provides a few useful helpers:\r\n\r\n* `can?` - for checking if the current_user is permitted an action on the\r\n  record\r\n* `authorize` - checks if the user can perform the action, otherwise raise\r\n  `Lawkeeper::NotAuthorized`\r\n* `skip_authorization` - used to flag an action as not needing authorization\r\n\r\n### Declaring policy classes\r\n\r\nBy default, Lawkeeper follows a convention of mapping policy classes like\r\n`PostPolicy` for a `Post` class, `CommentPolicy` for `Comment`, etc.\r\n\r\nThe simplest way to declare a post policy is inherit `Lawkeeper::Policy`\r\nand declare predicates for policy checks:\r\n\r\n```ruby\r\nclass PostPolicy < Lawkeeper::Policy\r\n  def read?\r\n    true\r\n  end\r\n\r\n  def update?\r\n    record.owned_by?(user)\r\n  end\r\nend\r\n```\r\n\r\nLawkeeper makes no assumptions about the name of your policy queries.  You can\r\ncall them `show?` or `read?`, `delete?` or `destroy?`, whichever you prefer.  The\r\nonly requirement is that they end with '?'.\r\n\r\nPolicy classes are instantiated with the current user and a record for checking.\r\n\r\nIf you wish to use an unconventially named Policy class for a model, add the\r\n`#policy_class` instance method to your model.  For example:\r\n\r\n```ruby\r\nclass Post\r\n  def policy_class\r\n    OwnershipPolicy\r\n  end\r\nend\r\n```\r\n\r\nLawkeeper helper methods will prefer the `#policy_class` specified if it exists.\r\n\r\n### Authorizing in actions\r\n\r\nTo authorize in a controller action is simple:\r\n\r\n```ruby\r\nget \"/post/:id\" do\r\n  @post = Post.find(id)\r\n  authorize @post, :read\r\n  erb :post_show\r\nend\r\n```\r\n\r\nIf authorize is permitted (which it usually should be) the action will continue\r\nas normal.  If it fails, Lawkeeper::NotAuthorized will be raised.\r\n\r\n### Checking in views\r\n\r\nLawkeeper provides a `can?` helper to use in your views:\r\n\r\n```ruby\r\n<% if can? :edit, @post %>\r\n  <a href=\"/posts/<%= @post.id %>/edit\">Edit Post</a>\r\n<% end %>\r\n```\r\n\r\nThe `can?` method is a check, it will not raise authorization exceptions.\r\n\r\n### Specifying policy classes\r\n\r\nIf you wish to specify a policy class at runtime for a call to `can?` or `authorize`,\r\nyou can pass a policy class as an option third argument.\r\n\r\n```ruby\r\nauthorize @post, :read, OwnershipPolicy\r\n```\r\n\r\n## Ensuring authorization with middlewares\r\n\r\nLawkeeper provides `EnsureWare` for checking that authorization was performed\r\nfor all actions.  When the `authorize` or `skip_authorization` methods are\r\nemployed in actions, response headers are set.  The middleware then checks\r\nand deletes the headers.  If the header was not present, a 403 forbidden status\r\nwill be returned.\r\n\r\nThis is useful to ensure you do not forget to authorize the resource in any\r\ngiven action.\r\n\r\nIf you do not wish to enforce such a check, you should employ the `ScrubWare`\r\nmiddleware instead.  This is simply responsible for stripping Lawkeeper headers\r\nbefore sending the response on its way.\r\n\r\nIf you'd prefer to not use middleware at all, it's advised you set Lawkeeper to\r\nsimply skip the setting of headers:\r\n\r\n```ruby\r\nLawkeeper.skip_set_headers = true\r\n```\r\n\r\nThis will not prevent how Lawkeeper does its primary job of authorizing policy\r\nactions.\r\n\r\n## Outstanding Problems\r\n\r\nLawkeeper as yet has no mechanism for scoping finds for collection 'index' like\r\nmethods.  Pundit (which Lawkeeper is influenced by) has some similiar problems\r\nin this area as well (though it does provide a scope object).\r\n\r\nThe primary challenges are:\r\n\r\n* A collection action is very different than an instance authorization, because\r\n  you don't authorize instances but rather find them via policy\r\n* As compared to instance authorization, scoped finding is very coupled to an\r\n  ORM, model, or storage pattern in a given application.\r\n\r\nMy immediate thinking for Lawkeeper is to call `skip_authorization` in actions\r\nwhere you have performed a scoped find.  This will likely keep development in check\r\nsince adding the call is a mental note for \"hey this should be permitted records only\"\r\n\r\nTo build upon this, I believe either:\r\n\r\n* The scoping should be up to you, or\r\n* The scope permission handling should delegate to third party ORM specific plugins.\r\n\r\nI am still rolling around this in my head, with the goal of keeping it simple\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Added some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}